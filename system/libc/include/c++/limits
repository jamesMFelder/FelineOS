/* SPDX-License-Identifier: MIT */
/* Copyright (c) 2021 James McNaughton Felder */

#ifndef _LIMITS
#define _LIMITS 1

/* Off-limits for a system header file, but I don't know what else to do. */
#include <climits>
#include <float.h>

namespace std{

/* How are floats rounded */
/* Copied from https://en.cppreference.com/w/cpp/types/numeric_limits/float_round_style */
enum float_round_style {
	round_indeterminate       = -1,
	round_toward_zero         = 0,
	round_to_nearest          = 1,
	round_toward_infinity     = 2,
	round_toward_neg_infinity = 3
};

/* How are floats denormalized */
/* Copied from https://en.cppreference.com/w/cpp/types/numeric_limits/float_denorm_style */
enum float_denorm_style {
	denorm_indeterminate = -1,
	denorm_absent        = 0,
	denorm_present       = 1
};

/* The base numeric_limits class */
/* Copied from https://en.cppreference.com/w/cpp/header/limits, https://www.cplusplus.com/reference/limits/numeric_limits/ and eel.is/c++draft/numeric.limits */
template <class T> class numeric_limits {
	public:
		static constexpr bool is_specialized = false;
		static constexpr T min() noexcept { return T(); }
		static constexpr T max() noexcept { return T(); }
		static constexpr T lowest() noexcept { return T(); }
		static constexpr int  digits = 0;
		static constexpr int  digits10 = 0;
		static constexpr bool is_signed = false;
		static constexpr bool is_integer = false;
		static constexpr bool is_exact = false;
		static constexpr int radix = 0;
		static constexpr T epsilon() noexcept { return T(); }
		static constexpr T round_error() noexcept { return T(); }

		static constexpr int  min_exponent = 0;
		static constexpr int  min_exponent10 = 0;
		static constexpr int  max_exponent = 0;
		static constexpr int  max_exponent10 = 0;

		static constexpr bool has_infinity = false;
		static constexpr bool has_quiet_NaN = false;
		static constexpr bool has_signaling_NaN = false;
		static constexpr float_denorm_style has_denorm = denorm_absent;
		static constexpr bool has_denorm_loss = false;
		static constexpr T infinity() noexcept { return T(); }
		static constexpr T quiet_NaN() noexcept { return T(); }
		static constexpr T signaling_NaN() noexcept { return T(); }
		static constexpr T denorm_min() noexcept { return T(); }

		static constexpr bool is_iec559 = false;
		static constexpr bool is_bounded = false;
		static constexpr bool is_modulo = false;

		static constexpr bool traps = false;
		static constexpr bool tinyness_before = false;
		static constexpr float_round_style round_style = round_toward_zero;
};

/* Bool */
template<> class numeric_limits<bool> {
	public:
		static constexpr bool is_specialized = true;

		static constexpr bool min() noexcept { return false; }
		static constexpr bool max() noexcept { return true; }
		static constexpr bool lowest() noexcept { return false; }

		static constexpr int digits = 1;
		static constexpr int digits10 = 0;
		static constexpr int max_digits10 = 0;

		static constexpr bool is_signed = false;
		static constexpr bool is_integer = true;
		static constexpr bool is_exact = true;
		static constexpr int radix = 2;
		static constexpr bool epsilon() noexcept { return 0; }
		static constexpr bool round_error() noexcept { return 0; }

		static constexpr int min_exponent = 0;
		static constexpr int min_exponent10 = 0;
		static constexpr int max_exponent = 0;
		static constexpr int max_exponent10 = 0;

		static constexpr bool has_infinity = false;
		static constexpr bool has_quiet_NaN = false;
		static constexpr bool has_signaling_NaN = false;
		static constexpr float_denorm_style has_denorm = denorm_absent;
		static constexpr bool has_denorm_loss = false;
		static constexpr bool infinity() noexcept { return false; }
		static constexpr bool quiet_NaN() noexcept { return false; }
		static constexpr bool signaling_NaN() noexcept { return false; }
		static constexpr bool denorm_min() noexcept { return false; }

		static constexpr bool is_iec559 = false;
		static constexpr bool is_bounded = true;
		static constexpr bool is_modulo = false;

		static constexpr bool traps = false;
		static constexpr bool tinyness_before = false;
		static constexpr float_round_style round_style = round_toward_zero;
};

/* Char */
template<> class numeric_limits<char>{
	public:
		static constexpr bool is_specialized = true;

		static constexpr char min() noexcept { return CHAR_MIN; }
		static constexpr char max() noexcept { return CHAR_MAX; }
		static constexpr char lowest() noexcept { return min(); }

		static constexpr int digits = 1;
		static constexpr int digits10 = 0;
		static constexpr int max_digits10 = 0;

		static constexpr bool is_signed = CHAR_MIN<0;
		static constexpr bool is_integer = true;
		static constexpr bool is_exact = true;
		static constexpr int radix = 2;
		static constexpr char epsilon() noexcept { return 0; }
		static constexpr char round_error() noexcept { return 0; }

		static constexpr int min_exponent = 0;
		static constexpr int min_exponent10 = 0;
		static constexpr int max_exponent = 0;
		static constexpr int max_exponent10 = 0;

		static constexpr bool has_infinity = false;
		static constexpr bool has_quiet_NaN = false;
		static constexpr bool has_signaling_NaN = false;
		static constexpr float_denorm_style has_denorm = denorm_absent;
		static constexpr bool has_denorm_loss = false;
		static constexpr bool infinity() noexcept { return 0; }
		static constexpr bool quiet_NaN() noexcept { return 0; }
		static constexpr bool signaling_NaN() noexcept { return 0; }
		static constexpr bool denorm_min() noexcept { return 0; }

		static constexpr bool is_iec559 = false;
		static constexpr bool is_bounded = true;
		static constexpr bool is_modulo = !is_signed;

		static constexpr bool traps = false;
		static constexpr bool tinyness_before = false;
		static constexpr float_round_style round_style = round_toward_zero;
};

/* Unsigned char */
template<> class numeric_limits<unsigned char>{
	public:
		static constexpr bool is_specialized = true;

		static constexpr unsigned char min() noexcept { return 0; }
		static constexpr unsigned char max() noexcept { return UCHAR_MAX; }
		static constexpr unsigned char lowest() noexcept { return min(); }

		static constexpr int digits = 1;
		static constexpr int digits10 = 0;
		static constexpr int max_digits10 = 0;

		static constexpr bool is_signed = false;
		static constexpr bool is_integer = true;
		static constexpr bool is_exact = true;
		static constexpr int radix = 2;
		static constexpr unsigned char epsilon() noexcept { return 0; }
		static constexpr unsigned char round_error() noexcept { return 0; }

		static constexpr int min_exponent = 0;
		static constexpr int min_exponent10 = 0;
		static constexpr int max_exponent = 0;
		static constexpr int max_exponent10 = 0;

		static constexpr bool has_infinity = false;
		static constexpr bool has_quiet_NaN = false;
		static constexpr bool has_signaling_NaN = false;
		static constexpr float_denorm_style has_denorm = denorm_absent;
		static constexpr bool has_denorm_loss = false;
		static constexpr bool infinity() noexcept { return 0; }
		static constexpr bool quiet_NaN() noexcept { return 0; }
		static constexpr bool signaling_NaN() noexcept { return 0; }
		static constexpr bool denorm_min() noexcept { return 0; }

		static constexpr bool is_iec559 = false;
		static constexpr bool is_bounded = true;
		static constexpr bool is_modulo = !is_signed;

		static constexpr bool traps = false;
		static constexpr bool tinyness_before = false;
		static constexpr float_round_style round_style = round_toward_zero;
};

/* Signed char */
template<> class numeric_limits<signed char>{
	public:
		static constexpr bool is_specialized = true;

		static constexpr signed char min() noexcept { return SCHAR_MIN; }
		static constexpr signed char max() noexcept { return SCHAR_MAX; }
		static constexpr signed char lowest() noexcept { return min(); }

		static constexpr int digits = 1;
		static constexpr int digits10 = 0;
		static constexpr int max_digits10 = 0;

		static constexpr bool is_signed = true;
		static constexpr bool is_integer = true;
		static constexpr bool is_exact = true;
		static constexpr int radix = 2;
		static constexpr signed char epsilon() noexcept { return 0; }
		static constexpr signed char round_error() noexcept { return 0; }

		static constexpr int min_exponent = 0;
		static constexpr int min_exponent10 = 0;
		static constexpr int max_exponent = 0;
		static constexpr int max_exponent10 = 0;

		static constexpr bool has_infinity = false;
		static constexpr bool has_quiet_NaN = false;
		static constexpr bool has_signaling_NaN = false;
		static constexpr float_denorm_style has_denorm = denorm_absent;
		static constexpr bool has_denorm_loss = false;
		static constexpr bool infinity() noexcept { return 0; }
		static constexpr bool quiet_NaN() noexcept { return 0; }
		static constexpr bool signaling_NaN() noexcept { return 0; }
		static constexpr bool denorm_min() noexcept { return 0; }

		static constexpr bool is_iec559 = false;
		static constexpr bool is_bounded = true;
		static constexpr bool is_modulo = !is_signed;

		static constexpr bool traps = false;
		static constexpr bool tinyness_before = false;
		static constexpr float_round_style round_style = round_toward_zero;
};

/* Short */
template<> class numeric_limits<short>{
	public:
		static constexpr bool is_specialized = true;

		static constexpr short min() noexcept { return SHRT_MIN; }
		static constexpr short max() noexcept { return SHRT_MAX; }
		static constexpr short lowest() noexcept { return min(); }

		static constexpr int digits = CHAR_BIT*sizeof(short)-1;
		static constexpr int digits10 = 0;
		static constexpr int max_digits10 = 0;

		static constexpr bool is_signed = true;
		static constexpr bool is_integer = true;
		static constexpr bool is_exact = true;
		static constexpr int radix = 2;
		static constexpr short epsilon() noexcept { return 0; }
		static constexpr short round_error() noexcept { return 0; }

		static constexpr int min_exponent = 0;
		static constexpr int min_exponent10 = 0;
		static constexpr int max_exponent = 0;
		static constexpr int max_exponent10 = 0;

		static constexpr bool has_infinity = false;
		static constexpr bool has_quiet_NaN = false;
		static constexpr bool has_signaling_NaN = false;
		static constexpr float_denorm_style has_denorm = denorm_absent;
		static constexpr bool has_denorm_loss = false;
		static constexpr bool infinity() noexcept { return 0; }
		static constexpr bool quiet_NaN() noexcept { return 0; }
		static constexpr bool signaling_NaN() noexcept { return 0; }
		static constexpr bool denorm_min() noexcept { return 0; }

		static constexpr bool is_iec559 = false;
		static constexpr bool is_bounded = true;
		static constexpr bool is_modulo = !is_signed;

		static constexpr bool traps = false;
		static constexpr bool tinyness_before = false;
		static constexpr float_round_style round_style = round_toward_zero;
};

/* Unsigned short */
template<> class numeric_limits<unsigned short>{
	public:
		static constexpr bool is_specialized = true;

		static constexpr unsigned short min() noexcept { return 0; }
		static constexpr unsigned short max() noexcept { return USHRT_MAX; }
		static constexpr unsigned short lowest() noexcept { return min(); }

		static constexpr int digits = CHAR_BIT*sizeof(unsigned short);
		static constexpr int digits10 = 0;
		static constexpr int max_digits10 = 0;

		static constexpr bool is_signed = false;
		static constexpr bool is_integer = true;
		static constexpr bool is_exact = true;
		static constexpr int radix = 2;
		static constexpr unsigned short epsilon() noexcept { return 0; }
		static constexpr unsigned short round_error() noexcept { return 0; }

		static constexpr int min_exponent = 0;
		static constexpr int min_exponent10 = 0;
		static constexpr int max_exponent = 0;
		static constexpr int max_exponent10 = 0;

		static constexpr bool has_infinity = false;
		static constexpr bool has_quiet_NaN = false;
		static constexpr bool has_signaling_NaN = false;
		static constexpr float_denorm_style has_denorm = denorm_absent;
		static constexpr bool has_denorm_loss = false;
		static constexpr bool infinity() noexcept { return 0; }
		static constexpr bool quiet_NaN() noexcept { return 0; }
		static constexpr bool signaling_NaN() noexcept { return 0; }
		static constexpr bool denorm_min() noexcept { return 0; }

		static constexpr bool is_iec559 = false;
		static constexpr bool is_bounded = true;
		static constexpr bool is_modulo = !is_signed;

		static constexpr bool traps = false;
		static constexpr bool tinyness_before = false;
		static constexpr float_round_style round_style = round_toward_zero;
};

/* Int */
template<> class numeric_limits<int>{
	public:
		static constexpr bool is_specialized = true;

		static constexpr int min() noexcept { return INT_MIN; }
		static constexpr int max() noexcept { return INT_MAX; }
		static constexpr int lowest() noexcept { return min(); }

		static constexpr int digits = CHAR_BIT*sizeof(int)-1;
		static constexpr int digits10 = 0;
		static constexpr int max_digits10 = 0;

		static constexpr bool is_signed = true;
		static constexpr bool is_integer = true;
		static constexpr bool is_exact = true;
		static constexpr int radix = 2;
		static constexpr int epsilon() noexcept { return 0; }
		static constexpr int round_error() noexcept { return 0; }

		static constexpr int min_exponent = 0;
		static constexpr int min_exponent10 = 0;
		static constexpr int max_exponent = 0;
		static constexpr int max_exponent10 = 0;

		static constexpr bool has_infinity = false;
		static constexpr bool has_quiet_NaN = false;
		static constexpr bool has_signaling_NaN = false;
		static constexpr float_denorm_style has_denorm = denorm_absent;
		static constexpr bool has_denorm_loss = false;
		static constexpr bool infinity() noexcept { return 0; }
		static constexpr bool quiet_NaN() noexcept { return 0; }
		static constexpr bool signaling_NaN() noexcept { return 0; }
		static constexpr bool denorm_min() noexcept { return 0; }

		static constexpr bool is_iec559 = false;
		static constexpr bool is_bounded = true;
		static constexpr bool is_modulo = !is_signed;

		static constexpr bool traps = false;
		static constexpr bool tinyness_before = false;
		static constexpr float_round_style round_style = round_toward_zero;
};

/* Unsigned int */
template<> class numeric_limits<unsigned int>{
	public:
		static constexpr bool is_specialized = true;

		static constexpr unsigned int min() noexcept { return 0; }
		static constexpr unsigned int max() noexcept { return UINT_MAX; }
		static constexpr unsigned int lowest() noexcept { return min(); }

		static constexpr int digits = CHAR_BIT*sizeof(unsigned int);
		static constexpr int digits10 = 0;
		static constexpr int max_digits10 = 0;

		static constexpr bool is_signed = false;
		static constexpr bool is_integer = true;
		static constexpr bool is_exact = true;
		static constexpr int radix = 2;
		static constexpr unsigned int epsilon() noexcept { return 0; }
		static constexpr unsigned int round_error() noexcept { return 0; }

		static constexpr int min_exponent = 0;
		static constexpr int min_exponent10 = 0;
		static constexpr int max_exponent = 0;
		static constexpr int max_exponent10 = 0;

		static constexpr bool has_infinity = false;
		static constexpr bool has_quiet_NaN = false;
		static constexpr bool has_signaling_NaN = false;
		static constexpr float_denorm_style has_denorm = denorm_absent;
		static constexpr bool has_denorm_loss = false;
		static constexpr bool infinity() noexcept { return 0; }
		static constexpr bool quiet_NaN() noexcept { return 0; }
		static constexpr bool signaling_NaN() noexcept { return 0; }
		static constexpr bool denorm_min() noexcept { return 0; }

		static constexpr bool is_iec559 = false;
		static constexpr bool is_bounded = true;
		static constexpr bool is_modulo = !is_signed;

		static constexpr bool traps = false;
		static constexpr bool tinyness_before = false;
		static constexpr float_round_style round_style = round_toward_zero;
};

/* Long */
template<> class numeric_limits<long>{
	public:
		static constexpr bool is_specialized = true;

		static constexpr long min() noexcept { return LONG_MIN; }
		static constexpr long max() noexcept { return LONG_MAX; }
		static constexpr long lowest() noexcept { return min(); }

		static constexpr int digits = CHAR_BIT*sizeof(long)-1;
		static constexpr int digits10 = 0;
		static constexpr int max_digits10 = 0;

		static constexpr bool is_signed = true;
		static constexpr bool is_integer = true;
		static constexpr bool is_exact = true;
		static constexpr int radix = 2;
		static constexpr long epsilon() noexcept { return 0; }
		static constexpr long round_error() noexcept { return 0; }

		static constexpr int min_exponent = 0;
		static constexpr int min_exponent10 = 0;
		static constexpr int max_exponent = 0;
		static constexpr int max_exponent10 = 0;

		static constexpr bool has_infinity = false;
		static constexpr bool has_quiet_NaN = false;
		static constexpr bool has_signaling_NaN = false;
		static constexpr float_denorm_style has_denorm = denorm_absent;
		static constexpr bool has_denorm_loss = false;
		static constexpr bool infinity() noexcept { return 0; }
		static constexpr bool quiet_NaN() noexcept { return 0; }
		static constexpr bool signaling_NaN() noexcept { return 0; }
		static constexpr bool denorm_min() noexcept { return 0; }

		static constexpr bool is_iec559 = false;
		static constexpr bool is_bounded = true;
		static constexpr bool is_modulo = !is_signed;

		static constexpr bool traps = false;
		static constexpr bool tinyness_before = false;
		static constexpr float_round_style round_style = round_toward_zero;
};

/* Unsigned long */
template<> class numeric_limits<unsigned long>{
	public:
		static constexpr bool is_specialized = true;

		static constexpr unsigned long min() noexcept { return 0; }
		static constexpr unsigned long max() noexcept { return ULONG_MAX; }
		static constexpr unsigned long lowest() noexcept { return min(); }

		static constexpr int digits = CHAR_BIT*sizeof(unsigned long);
		static constexpr int digits10 = 0;
		static constexpr int max_digits10 = 0;

		static constexpr bool is_signed = false;
		static constexpr bool is_integer = true;
		static constexpr bool is_exact = true;
		static constexpr int radix = 2;
		static constexpr unsigned long epsilon() noexcept { return 0; }
		static constexpr unsigned long round_error() noexcept { return 0; }

		static constexpr int min_exponent = 0;
		static constexpr int min_exponent10 = 0;
		static constexpr int max_exponent = 0;
		static constexpr int max_exponent10 = 0;

		static constexpr bool has_infinity = false;
		static constexpr bool has_quiet_NaN = false;
		static constexpr bool has_signaling_NaN = false;
		static constexpr float_denorm_style has_denorm = denorm_absent;
		static constexpr bool has_denorm_loss = false;
		static constexpr bool infinity() noexcept { return 0; }
		static constexpr bool quiet_NaN() noexcept { return 0; }
		static constexpr bool signaling_NaN() noexcept { return 0; }
		static constexpr bool denorm_min() noexcept { return 0; }

		static constexpr bool is_iec559 = false;
		static constexpr bool is_bounded = true;
		static constexpr bool is_modulo = !is_signed;

		static constexpr bool traps = false;
		static constexpr bool tinyness_before = false;
		static constexpr float_round_style round_style = round_toward_zero;
};

/* Long long */
template<> class numeric_limits<long long>{
	public:
		static constexpr bool is_specialized = true;

		static constexpr long long min() noexcept { return LLONG_MIN; }
		static constexpr long long max() noexcept { return LLONG_MAX; }
		static constexpr long long lowest() noexcept { return min(); }

		static constexpr int digits = CHAR_BIT*sizeof(long long)-1;
		static constexpr int digits10 = 0;
		static constexpr int max_digits10 = 0;

		static constexpr bool is_signed = true;
		static constexpr bool is_integer = true;
		static constexpr bool is_exact = true;
		static constexpr int radix = 2;
		static constexpr long long epsilon() noexcept { return 0; }
		static constexpr long long round_error() noexcept { return 0; }

		static constexpr int min_exponent = 0;
		static constexpr int min_exponent10 = 0;
		static constexpr int max_exponent = 0;
		static constexpr int max_exponent10 = 0;

		static constexpr bool has_infinity = false;
		static constexpr bool has_quiet_NaN = false;
		static constexpr bool has_signaling_NaN = false;
		static constexpr float_denorm_style has_denorm = denorm_absent;
		static constexpr bool has_denorm_loss = false;
		static constexpr bool infinity() noexcept { return 0; }
		static constexpr bool quiet_NaN() noexcept { return 0; }
		static constexpr bool signaling_NaN() noexcept { return 0; }
		static constexpr bool denorm_min() noexcept { return 0; }

		static constexpr bool is_iec559 = false;
		static constexpr bool is_bounded = true;
		static constexpr bool is_modulo = !is_signed;

		static constexpr bool traps = false;
		static constexpr bool tinyness_before = false;
		static constexpr float_round_style round_style = round_toward_zero;
};

/* Unsigned long long */
template<> class numeric_limits<unsigned long long>{
	public:
		static constexpr bool is_specialized = true;

		static constexpr unsigned long long min() noexcept { return 0; }
		static constexpr unsigned long long max() noexcept { return ULLONG_MAX; }
		static constexpr unsigned long long lowest() noexcept { return min(); }

		static constexpr int digits = CHAR_BIT*sizeof(unsigned long long);
		static constexpr int digits10 = 0;
		static constexpr int max_digits10 = 0;

		static constexpr bool is_signed = false;
		static constexpr bool is_integer = true;
		static constexpr bool is_exact = true;
		static constexpr int radix = 2;
		static constexpr unsigned long long epsilon() noexcept { return 0; }
		static constexpr unsigned long long round_error() noexcept { return 0; }

		static constexpr int min_exponent = 0;
		static constexpr int min_exponent10 = 0;
		static constexpr int max_exponent = 0;
		static constexpr int max_exponent10 = 0;

		static constexpr bool has_infinity = false;
		static constexpr bool has_quiet_NaN = false;
		static constexpr bool has_signaling_NaN = false;
		static constexpr float_denorm_style has_denorm = denorm_absent;
		static constexpr bool has_denorm_loss = false;
		static constexpr bool infinity() noexcept { return 0; }
		static constexpr bool quiet_NaN() noexcept { return 0; }
		static constexpr bool signaling_NaN() noexcept { return 0; }
		static constexpr bool denorm_min() noexcept { return 0; }

		static constexpr bool is_iec559 = false;
		static constexpr bool is_bounded = true;
		static constexpr bool is_modulo = !is_signed;

		static constexpr bool traps = false;
		static constexpr bool tinyness_before = false;
		static constexpr float_round_style round_style = round_toward_zero;
};

}

#endif /* _LIMITS_H */
